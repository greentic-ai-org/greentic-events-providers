# provider-webhook Codex

You are the **provider-webhook** Codex in the `greentic-events-providers` workspace.

## Purpose

Implement a **generic Webhook event provider** as WASM components with packs:

- `events-webhook-source@1.0.0` – `source` world:
  - Accepts HTTP events from the host.
  - Emits `EventEnvelope`s into greentic-events.
- (later) `events-webhook-sink@1.0.0` – `sink` world:
  - Accepts events and transforms them into outgoing HTTP requests.

These components **do not** open HTTP ports themselves; they receive serialized HTTP request data via host calls and return events.

## Dependencies

- `provider-core` (for configs, event helpers, errors).
- `greentic-types` (EventEnvelope, TenantCtx).
- `greentic-interfaces-guest` (bindings for `greentic:events@1.0.0` worlds and any HTTP bridging world, if defined).
- `serde`, `serde_json`.

## Tasks

### 1. Component interface (source)

Implement a WASM component `events-webhook-source@1.0.0`:

- Use `greentic-interfaces-guest` bindings for `greentic:events@1.0.0` `source` world.
- Expect to be called by the host with:
  - `HttpEndpointConfig` (from provider-core) at init time.
  - A function per incoming HTTP request, with serialized HTTP request info:
    - method, path, headers, body, tenant context.

Inside the component:

1. Match the incoming request’s `path` against configured `WebhookRoute`s.
2. Resolve the `topic_prefix` for that route (e.g. `webhook.stripe`).
3. Optionally validate a signature:
   - For now, only **structure** the code; secret fetching and HMAC can be stubbed/mocked (we will refine with greentic-secrets later).
4. Build an `EventEnvelope` via `provider-core::new_event`, using:
   - `topic = format!("{prefix}.{}", event_type_or_default)`
   - `type_ = "com.greentic.webhook.generic.v1"`
   - `source = "webhook-gateway"`
   - `subject = Some(path)`
   - `payload = raw JSON body`
   - `metadata` includes HTTP headers, method, path, signature_valid flag, correlation_id if present.

Return the envelope via the `source` world’s API.

### 2. (Optional v1) Component interface (sink)

Define a stub `events-webhook-sink@1.0.0` that:

- Implements `sink` world.
- Accepts an `EventEnvelope` + sink config (e.g. target URL).
- For v1:
  - Can simply log or store an internal representation.
  - Real HTTP sending can be added later when host integration is clear.

### 3. Pack definition

Under `packs/events/webhook.yaml`, define:

```yaml
events:
  providers:
    - name: "webhook-gateway"
      kind: "source"
      component: "events-webhook-source@1.0.0"
      default_flow: "flows/events/webhook/in_default.ygtc"
      custom_flow: "flows/events/webhook/in_custom.ygtc"
      capabilities:
        transport: "webhook"
        reliability: "at_least_once"
        ordering: "none"
        topics:
          - "webhook.*"
```

Do not define a new schema; conform to greentic-pack’s events.providers schema.

Ensure IDs and paths are consistent with actual files.

### 4. Flows
Create stub/default flows under flows/events/webhook/:
- `in_default.ygtc`:
  - Simple flow: Webhook source → greentic-events bus.
- `in_custom_template.ygtc`:
  - Commented template with placeholders (document how a user can customise mapping).
- Flows can be very minimal; the key is to have valid files referenced by the pack.

### 5. Tests
Unit tests for the core mapping logic:
- Given a HttpEndpointConfig and a sample HTTP request, the component produces an EventEnvelope with the expected topic, payload, and metadata.

WASM-ish test (if feasible):
- Build the component for wasm32-wasip2.
- Use wasmtime + greentic-interfaces-host in a test harness to call the source function with a sample HTTP event and inspect the resulting envelope.

Pack consistency test:
- Verify `packs/events/webhook.yaml` YAML can be parsed and references existing component IDs/flow paths (a simple test in this repo).

## Constraints
- No HTTP server; treat HTTP as an abstract payload passed by host.
- No greentic-events dependency; events are produced via the WIT interface only.
- No oauth/msgraph specifics here; this provider should work for Stripe, GitHub, etc. in a generic way.
