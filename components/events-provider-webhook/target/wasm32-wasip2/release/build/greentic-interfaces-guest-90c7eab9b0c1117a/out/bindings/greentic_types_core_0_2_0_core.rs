// Generated by `wit-bindgen` 0.52.0. DO NOT EDIT!
// Options used:
//   * generate_unused_types
#[allow(dead_code, clippy::all)]
pub mod greentic {
  pub mod interfaces_types {

    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod types {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      /// Environment identifier.
      pub type EnvId = _rt::String;
      /// Tenant identifier propagated across providers.
      pub type TenantId = _rt::String;
      /// Team identifier scoped to a tenant.
      pub type TeamId = _rt::String;
      /// User identifier scoped to a tenant.
      pub type UserId = _rt::String;
      /// Stable key referencing persisted state blobs.
      pub type StateKey = _rt::String;
      /// Stable key referencing sessions.
      pub type SessionKey = _rt::String;
      /// Impersonation context propagated with a tenant.
      #[derive(Clone)]
      pub struct Impersonation {
        pub actor_id: UserId,
        pub reason: Option<_rt::String>,
      }
      impl ::core::fmt::Debug for Impersonation {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Impersonation").field("actor-id", &self.actor_id).field("reason", &self.reason).finish()
        }
      }
      /// Invocation tenant context shared across Greentic surfaces.
      #[derive(Clone)]
      pub struct TenantCtx {
        pub env: EnvId,
        pub tenant: TenantId,
        pub tenant_id: TenantId,
        pub team: Option<TeamId>,
        pub team_id: Option<TeamId>,
        pub user: Option<UserId>,
        pub user_id: Option<UserId>,
        pub trace_id: Option<_rt::String>,
        pub i18n_id: Option<_rt::String>,
        pub correlation_id: Option<_rt::String>,
        pub attributes: _rt::Vec::<(_rt::String,_rt::String,)>,
        pub session_id: Option<_rt::String>,
        pub flow_id: Option<_rt::String>,
        pub node_id: Option<_rt::String>,
        pub provider_id: Option<_rt::String>,
        pub deadline_ms: Option<i64>,
        pub attempt: u32,
        pub idempotency_key: Option<_rt::String>,
        pub impersonation: Option<Impersonation>,
      }
      impl ::core::fmt::Debug for TenantCtx {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("TenantCtx").field("env", &self.env).field("tenant", &self.tenant).field("tenant-id", &self.tenant_id).field("team", &self.team).field("team-id", &self.team_id).field("user", &self.user).field("user-id", &self.user_id).field("trace-id", &self.trace_id).field("i18n-id", &self.i18n_id).field("correlation-id", &self.correlation_id).field("attributes", &self.attributes).field("session-id", &self.session_id).field("flow-id", &self.flow_id).field("node-id", &self.node_id).field("provider-id", &self.provider_id).field("deadline-ms", &self.deadline_ms).field("attempt", &self.attempt).field("idempotency-key", &self.idempotency_key).field("impersonation", &self.impersonation).finish()
        }
      }
      /// Cursor describing a session position.
      #[derive(Clone)]
      pub struct SessionCursor {
        pub node_pointer: _rt::String,
        pub wait_reason: Option<_rt::String>,
        pub outbox_marker: Option<_rt::String>,
      }
      impl ::core::fmt::Debug for SessionCursor {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("SessionCursor").field("node-pointer", &self.node_pointer).field("wait-reason", &self.wait_reason).field("outbox-marker", &self.outbox_marker).finish()
        }
      }
      /// Canonical error codes surfaced by the platform.
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum ErrorCode {
        Unknown,
        InvalidInput,
        NotFound,
        Conflict,
        Timeout,
        Unauthenticated,
        PermissionDenied,
        RateLimited,
        Unavailable,
        Internal,
      }
      impl ::core::fmt::Debug for ErrorCode {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            ErrorCode::Unknown => {
              f.debug_tuple("ErrorCode::Unknown").finish()
            }
            ErrorCode::InvalidInput => {
              f.debug_tuple("ErrorCode::InvalidInput").finish()
            }
            ErrorCode::NotFound => {
              f.debug_tuple("ErrorCode::NotFound").finish()
            }
            ErrorCode::Conflict => {
              f.debug_tuple("ErrorCode::Conflict").finish()
            }
            ErrorCode::Timeout => {
              f.debug_tuple("ErrorCode::Timeout").finish()
            }
            ErrorCode::Unauthenticated => {
              f.debug_tuple("ErrorCode::Unauthenticated").finish()
            }
            ErrorCode::PermissionDenied => {
              f.debug_tuple("ErrorCode::PermissionDenied").finish()
            }
            ErrorCode::RateLimited => {
              f.debug_tuple("ErrorCode::RateLimited").finish()
            }
            ErrorCode::Unavailable => {
              f.debug_tuple("ErrorCode::Unavailable").finish()
            }
            ErrorCode::Internal => {
              f.debug_tuple("ErrorCode::Internal").finish()
            }
          }
        }
      }

      impl ErrorCode{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> ErrorCode{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => ErrorCode::Unknown,
            1 => ErrorCode::InvalidInput,
            2 => ErrorCode::NotFound,
            3 => ErrorCode::Conflict,
            4 => ErrorCode::Timeout,
            5 => ErrorCode::Unauthenticated,
            6 => ErrorCode::PermissionDenied,
            7 => ErrorCode::RateLimited,
            8 => ErrorCode::Unavailable,
            9 => ErrorCode::Internal,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      /// Canonical host error payload.
      #[derive(Clone)]
      pub struct HostError {
        pub code: _rt::String,
        pub message: _rt::String,
      }
      impl ::core::fmt::Debug for HostError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("HostError").field("code", &self.code).field("message", &self.message).finish()
        }
      }
      /// Standard error codes returned by host services.
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum IfaceError {
        InvalidArg,
        NotFound,
        Denied,
        Unavailable,
        Internal,
      }
      impl ::core::fmt::Debug for IfaceError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            IfaceError::InvalidArg => {
              f.debug_tuple("IfaceError::InvalidArg").finish()
            }
            IfaceError::NotFound => {
              f.debug_tuple("IfaceError::NotFound").finish()
            }
            IfaceError::Denied => {
              f.debug_tuple("IfaceError::Denied").finish()
            }
            IfaceError::Unavailable => {
              f.debug_tuple("IfaceError::Unavailable").finish()
            }
            IfaceError::Internal => {
              f.debug_tuple("IfaceError::Internal").finish()
            }
          }
        }
      }

      impl IfaceError{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> IfaceError{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => IfaceError::InvalidArg,
            1 => IfaceError::NotFound,
            2 => IfaceError::Denied,
            3 => IfaceError::Unavailable,
            4 => IfaceError::Internal,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      /// Pending outcome payload.
      #[derive(Clone)]
      pub struct OutcomePending {
        pub reason: _rt::String,
        pub expected_input: Option<_rt::Vec::<_rt::String>>,
      }
      impl ::core::fmt::Debug for OutcomePending {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("OutcomePending").field("reason", &self.reason).field("expected-input", &self.expected_input).finish()
        }
      }
      /// Error outcome payload.
      #[derive(Clone)]
      pub struct OutcomeError {
        pub code: ErrorCode,
        pub message: _rt::String,
      }
      impl ::core::fmt::Debug for OutcomeError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("OutcomeError").field("code", &self.code).field("message", &self.message).finish()
        }
      }
      /// Execution outcome for string payloads.
      #[derive(Clone)]
      pub enum Outcome {
        Done(_rt::String),
        Pending(OutcomePending),
        Error(OutcomeError),
      }
      impl ::core::fmt::Debug for Outcome {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            Outcome::Done(e) => {
              f.debug_tuple("Outcome::Done").field(e).finish()
            }
            Outcome::Pending(e) => {
              f.debug_tuple("Outcome::Pending").field(e).finish()
            }
            Outcome::Error(e) => {
              f.debug_tuple("Outcome::Error").field(e).finish()
            }
          }
        }
      }
      /// Supported network protocols.
      #[derive(Clone)]
      pub enum Protocol {
        Http,
        Https,
        Tcp,
        Udp,
        Grpc,
        Custom(_rt::String),
      }
      impl ::core::fmt::Debug for Protocol {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            Protocol::Http => {
              f.debug_tuple("Protocol::Http").finish()
            }
            Protocol::Https => {
              f.debug_tuple("Protocol::Https").finish()
            }
            Protocol::Tcp => {
              f.debug_tuple("Protocol::Tcp").finish()
            }
            Protocol::Udp => {
              f.debug_tuple("Protocol::Udp").finish()
            }
            Protocol::Grpc => {
              f.debug_tuple("Protocol::Grpc").finish()
            }
            Protocol::Custom(e) => {
              f.debug_tuple("Protocol::Custom").field(e).finish()
            }
          }
        }
      }
      /// Allow list describing permitted connectivity.
      #[derive(Clone)]
      pub struct AllowList {
        pub domains: _rt::Vec::<_rt::String>,
        pub ports: _rt::Vec::<u16>,
        pub protocols: _rt::Vec::<Protocol>,
      }
      impl ::core::fmt::Debug for AllowList {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("AllowList").field("domains", &self.domains).field("ports", &self.ports).field("protocols", &self.protocols).finish()
        }
      }
      /// Network policy composed of allow lists.
      #[derive(Clone)]
      pub struct NetworkPolicy {
        pub egress: AllowList,
        pub deny_on_miss: bool,
      }
      impl ::core::fmt::Debug for NetworkPolicy {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("NetworkPolicy").field("egress", &self.egress).field("deny-on-miss", &self.deny_on_miss).finish()
        }
      }
      /// Detached signature accompanying a pack.
      #[derive(Clone)]
      pub enum SignatureAlgorithm {
        Ed25519,
        Other(_rt::String),
      }
      impl ::core::fmt::Debug for SignatureAlgorithm {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            SignatureAlgorithm::Ed25519 => {
              f.debug_tuple("SignatureAlgorithm::Ed25519").finish()
            }
            SignatureAlgorithm::Other(e) => {
              f.debug_tuple("SignatureAlgorithm::Other").field(e).finish()
            }
          }
        }
      }
      #[derive(Clone)]
      pub struct Signature {
        pub key_id: _rt::String,
        pub algorithm: SignatureAlgorithm,
        pub signature: _rt::Vec::<u8>,
      }
      impl ::core::fmt::Debug for Signature {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Signature").field("key-id", &self.key_id).field("algorithm", &self.algorithm).field("signature", &self.signature).finish()
        }
      }
      /// Pack reference stored in registries.
      #[derive(Clone)]
      pub struct PackRef {
        pub oci_url: _rt::String,
        pub version: _rt::String,
        pub digest: _rt::String,
        pub signatures: _rt::Vec::<Signature>,
      }
      impl ::core::fmt::Debug for PackRef {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("PackRef").field("oci-url", &self.oci_url).field("version", &self.version).field("digest", &self.digest).field("signatures", &self.signatures).finish()
        }
      }
      /// Minimal telemetry span context.
      #[derive(Clone)]
      pub struct SpanContext {
        pub tenant: TenantId,
        pub session_id: Option<SessionKey>,
        pub flow_id: _rt::String,
        pub node_id: Option<_rt::String>,
        pub provider: _rt::String,
        pub start_ms: Option<i64>,
        pub end_ms: Option<i64>,
      }
      impl ::core::fmt::Debug for SpanContext {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("SpanContext").field("tenant", &self.tenant).field("session-id", &self.session_id).field("flow-id", &self.flow_id).field("node-id", &self.node_id).field("provider", &self.provider).field("start-ms", &self.start_ms).field("end-ms", &self.end_ms).finish()
        }
      }

    }

  }
}
#[allow(dead_code, clippy::all)]
pub mod exports {
  pub mod greentic {
    pub mod types_core {

      #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
      pub mod shared {
        #[used]
        #[doc(hidden)]
        static __FORCE_SECTION_REF: fn() =
        super::super::super::super::__link_custom_section_describing_imports;
        
        use super::super::super::super::_rt;
        pub type TenantId = super::super::super::super::greentic::interfaces_types::types::TenantId;
        pub type TeamId = super::super::super::super::greentic::interfaces_types::types::TeamId;
        pub type UserId = super::super::super::super::greentic::interfaces_types::types::UserId;
        pub type TenantCtx = super::super::super::super::greentic::interfaces_types::types::TenantCtx;
        pub type IfaceError = super::super::super::super::greentic::interfaces_types::types::IfaceError;
        /// Unique identifier for a flow definition.
        pub type FlowId = _rt::String;
        /// Supported cloud providers.
        #[derive(Clone, Copy)]
        pub enum Cloud {
          Aws,
          Gcp,
          Azure,
          Hetzner,
          Local,
          Other,
        }
        impl ::core::fmt::Debug for Cloud {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            match self {
              Cloud::Aws => {
                f.debug_tuple("Cloud::Aws").finish()
              }
              Cloud::Gcp => {
                f.debug_tuple("Cloud::Gcp").finish()
              }
              Cloud::Azure => {
                f.debug_tuple("Cloud::Azure").finish()
              }
              Cloud::Hetzner => {
                f.debug_tuple("Cloud::Hetzner").finish()
              }
              Cloud::Local => {
                f.debug_tuple("Cloud::Local").finish()
              }
              Cloud::Other => {
                f.debug_tuple("Cloud::Other").finish()
              }
            }
          }
        }
        /// Supported runtime platforms.
        #[derive(Clone, Copy)]
        pub enum Platform {
          K8s,
          Nomad,
          Systemd,
          Cfworkers,
          Lambda,
          Baremetal,
          Other,
        }
        impl ::core::fmt::Debug for Platform {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            match self {
              Platform::K8s => {
                f.debug_tuple("Platform::K8s").finish()
              }
              Platform::Nomad => {
                f.debug_tuple("Platform::Nomad").finish()
              }
              Platform::Systemd => {
                f.debug_tuple("Platform::Systemd").finish()
              }
              Platform::Cfworkers => {
                f.debug_tuple("Platform::Cfworkers").finish()
              }
              Platform::Lambda => {
                f.debug_tuple("Platform::Lambda").finish()
              }
              Platform::Baremetal => {
                f.debug_tuple("Platform::Baremetal").finish()
              }
              Platform::Other => {
                f.debug_tuple("Platform::Other").finish()
              }
            }
          }
        }
        /// Deployment information where the flow executes.
        #[derive(Clone)]
        pub struct DeploymentCtx {
          pub cloud: Cloud,
          pub region: Option<_rt::String>,
          pub platform: Platform,
          pub runtime: Option<_rt::String>,
          pub i18n_id: Option<_rt::String>,
        }
        impl ::core::fmt::Debug for DeploymentCtx {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("DeploymentCtx").field("cloud", &self.cloud).field("region", &self.region).field("platform", &self.platform).field("runtime", &self.runtime).field("i18n-id", &self.i18n_id).finish()
          }
        }
        /// Describes a flow that can be invoked by the pack.
        #[derive(Clone)]
        pub struct FlowInfo {
          pub id: FlowId,
          pub profile: _rt::String,
          pub version: _rt::String,
          pub flow_type: _rt::String,
          pub private: bool,
        }
        impl ::core::fmt::Debug for FlowInfo {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("FlowInfo").field("id", &self.id).field("profile", &self.profile).field("version", &self.version).field("flow-type", &self.flow_type).field("private", &self.private).finish()
          }
        }
        /// Runtime configuration when executing a flow.
        #[derive(Clone)]
        pub struct RunOpts {
          pub tenant: Option<TenantCtx>,
          pub deployment: Option<DeploymentCtx>,
          pub timeout_ms: Option<u32>,
          pub fuel_units: Option<u64>,
        }
        impl ::core::fmt::Debug for RunOpts {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("RunOpts").field("tenant", &self.tenant).field("deployment", &self.deployment).field("timeout-ms", &self.timeout_ms).field("fuel-units", &self.fuel_units).finish()
          }
        }
        /// Schema description for flow inputs and outputs.
        #[derive(Clone)]
        pub struct SchemaDoc {
          pub input_jsonschema: _rt::String,
          pub output_jsonschema: _rt::String,
        }
        impl ::core::fmt::Debug for SchemaDoc {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("SchemaDoc").field("input-jsonschema", &self.input_jsonschema).field("output-jsonschema", &self.output_jsonschema).finish()
          }
        }
        /// Result returned from executing a flow.
        #[derive(Clone)]
        pub struct RunResult {
          pub status: _rt::String,
          pub output_json: Option<_rt::String>,
          pub error: Option<_rt::String>,
          pub logs_json: Option<_rt::String>,
          pub metrics_json: Option<_rt::String>,
        }
        impl ::core::fmt::Debug for RunResult {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("RunResult").field("status", &self.status).field("output-json", &self.output_json).field("error", &self.error).field("logs-json", &self.logs_json).field("metrics-json", &self.metrics_json).finish()
          }
        }
        /// Candidate returned from an A2A search.
        #[derive(Clone)]
        pub struct A2aCandidate {
          pub flow: FlowId,
          pub score: f32,
        }
        impl ::core::fmt::Debug for A2aCandidate {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("A2aCandidate").field("flow", &self.flow).field("score", &self.score).finish()
          }
        }
        #[doc(hidden)]

        macro_rules! __export_greentic_types_core_shared_0_2_0_cabi{
          ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

          };);
        }
        #[doc(hidden)]
        pub(crate) use __export_greentic_types_core_shared_0_2_0_cabi;

      }

    }
  }
}
mod _rt {
  #![allow(dead_code, unused_imports, clippy::all)]
  pub use alloc_crate::string::String;
  pub use alloc_crate::vec::Vec;
  extern crate alloc as alloc_crate;
}

/// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
/// the root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]

macro_rules! __export_core_impl {
  ($ty:ident) => (self::export!($ty with_types_in self););
  ($ty:ident with_types_in $($path_to_types_root:tt)*) => (
  $($path_to_types_root)*::exports::greentic::types_core::shared::__export_greentic_types_core_shared_0_2_0_cabi!($ty with_types_in $($path_to_types_root)*::exports::greentic::types_core::shared);
  )
}
#[doc(inline)]
pub(crate) use __export_core_impl as export;

#[cfg(target_arch = "wasm32")]
#[unsafe(link_section = "component-type:wit-bindgen:0.52.0:greentic:types-core@0.2.0:core:encoded world")]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 2160] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xf5\x0f\x01A\x02\x01\
A\x09\x01B:\x01s\x04\0\x06env-id\x03\0\0\x01s\x04\0\x09tenant-id\x03\0\x02\x01s\x04\
\0\x07team-id\x03\0\x04\x01s\x04\0\x07user-id\x03\0\x06\x01s\x04\0\x09state-key\x03\
\0\x08\x01s\x04\0\x0bsession-key\x03\0\x0a\x01ks\x01r\x02\x08actor-id\x07\x06rea\
son\x0c\x04\0\x0dimpersonation\x03\0\x0d\x01k\x05\x01k\x07\x01o\x02ss\x01p\x11\x01\
kx\x01k\x0e\x01r\x13\x03env\x01\x06tenant\x03\x09tenant-id\x03\x04team\x0f\x07te\
am-id\x0f\x04user\x10\x07user-id\x10\x08trace-id\x0c\x07i18n-id\x0c\x0ecorrelati\
on-id\x0c\x0aattributes\x12\x0asession-id\x0c\x07flow-id\x0c\x07node-id\x0c\x0bp\
rovider-id\x0c\x0bdeadline-ms\x13\x07attempty\x0fidempotency-key\x0c\x0dimperson\
ation\x14\x04\0\x0atenant-ctx\x03\0\x15\x01r\x03\x0cnode-pointers\x0bwait-reason\
\x0c\x0doutbox-marker\x0c\x04\0\x0esession-cursor\x03\0\x17\x01m\x0a\x07unknown\x0d\
invalid-input\x09not-found\x08conflict\x07timeout\x0funauthenticated\x11permissi\
on-denied\x0crate-limited\x0bunavailable\x08internal\x04\0\x0aerror-code\x03\0\x19\
\x01r\x02\x04codes\x07messages\x04\0\x0ahost-error\x03\0\x1b\x01m\x05\x0binvalid\
-arg\x09not-found\x06denied\x0bunavailable\x08internal\x04\0\x0biface-error\x03\0\
\x1d\x01ps\x01k\x1f\x01r\x02\x06reasons\x0eexpected-input\x20\x04\0\x0foutcome-p\
ending\x03\0!\x01r\x02\x04code\x1a\x07messages\x04\0\x0doutcome-error\x03\0#\x01\
q\x03\x04done\x01s\0\x07pending\x01\"\0\x05error\x01$\0\x04\0\x07outcome\x03\0%\x01\
q\x06\x04http\0\0\x05https\0\0\x03tcp\0\0\x03udp\0\0\x04grpc\0\0\x06custom\x01s\0\
\x04\0\x08protocol\x03\0'\x01p{\x01p(\x01r\x03\x07domains\x1f\x05ports)\x09proto\
cols*\x04\0\x0aallow-list\x03\0+\x01r\x02\x06egress,\x0cdeny-on-miss\x7f\x04\0\x0e\
network-policy\x03\0-\x01q\x02\x07ed25519\0\0\x05other\x01s\0\x04\0\x13signature\
-algorithm\x03\0/\x01p}\x01r\x03\x06key-ids\x09algorithm0\x09signature1\x04\0\x09\
signature\x03\02\x01p3\x01r\x04\x07oci-urls\x07versions\x06digests\x0asignatures\
4\x04\0\x08pack-ref\x03\05\x01k\x0b\x01r\x07\x06tenant\x03\x0asession-id7\x07flo\
w-ids\x07node-id\x0c\x08providers\x08start-ms\x13\x06end-ms\x13\x04\0\x0cspan-co\
ntext\x03\08\x03\0%greentic:interfaces-types/types@0.1.0\x05\0\x02\x03\0\0\x09te\
nant-id\x02\x03\0\0\x07team-id\x02\x03\0\0\x07user-id\x02\x03\0\0\x0atenant-ctx\x02\
\x03\0\0\x0biface-error\x01B!\x02\x03\x02\x01\x01\x04\0\x09tenant-id\x03\0\0\x02\
\x03\x02\x01\x02\x04\0\x07team-id\x03\0\x02\x02\x03\x02\x01\x03\x04\0\x07user-id\
\x03\0\x04\x02\x03\x02\x01\x04\x04\0\x0atenant-ctx\x03\0\x06\x02\x03\x02\x01\x05\
\x04\0\x0biface-error\x03\0\x08\x01s\x04\0\x07flow-id\x03\0\x0a\x01q\x06\x03aws\0\
\0\x03gcp\0\0\x05azure\0\0\x07hetzner\0\0\x05local\0\0\x05other\0\0\x04\0\x05clo\
ud\x03\0\x0c\x01q\x07\x03k8s\0\0\x05nomad\0\0\x07systemd\0\0\x09cfworkers\0\0\x06\
lambda\0\0\x09baremetal\0\0\x05other\0\0\x04\0\x08platform\x03\0\x0e\x01ks\x01r\x05\
\x05cloud\x0d\x06region\x10\x08platform\x0f\x07runtime\x10\x07i18n-id\x10\x04\0\x0e\
deployment-ctx\x03\0\x11\x01r\x05\x02id\x0b\x07profiles\x07versions\x09flow-type\
s\x07private\x7f\x04\0\x09flow-info\x03\0\x13\x01k\x07\x01k\x12\x01ky\x01kw\x01r\
\x04\x06tenant\x15\x0adeployment\x16\x0atimeout-ms\x17\x0afuel-units\x18\x04\0\x08\
run-opts\x03\0\x19\x01r\x02\x10input-jsonschemas\x11output-jsonschemas\x04\0\x0a\
schema-doc\x03\0\x1b\x01r\x05\x06statuss\x0boutput-json\x10\x05error\x10\x09logs\
-json\x10\x0cmetrics-json\x10\x04\0\x0arun-result\x03\0\x1d\x01r\x02\x04flow\x0b\
\x05scorev\x04\0\x0da2a-candidate\x03\0\x1f\x04\0\x20greentic:types-core/shared@\
0.2.0\x05\x06\x04\0\x1egreentic:types-core/core@0.2.0\x04\0\x0b\x0a\x01\0\x04cor\
e\x03\0\0\0G\x09producers\x01\x0cprocessed-by\x02\x0dwit-component\x070.244.0\x10\
wit-bindgen-rust\x060.52.0";

#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
  wit_bindgen::rt::maybe_link_cabi_realloc();
}

